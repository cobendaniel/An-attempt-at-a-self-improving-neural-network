import pandas as pd 
import numpy as np 
import time 
import os 
import datetime as dt
from sklearn.model_selection import train_test_split 
import tensorflow as tf 
from tensorflow.keras.optimizers import SGD, Adam, Adadelta, Adagrad, Adamax, Nadam, Ftrl
import keras
from tensorflow.keras import callbacks
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.metrics import classification_report, r2_score, accuracy_score, recall_score, precision_score, f1_score
from proc_freq import proc_freq
import tensorflow as tf
import json

class neuralModeler_v2:
    def constructor(self, dictionary: dict):
        self.layer_num           = dictionary["layer_num"]
        self.base_neurons        = dictionary["base_neurons"]
        self.activation_function = dictionary["activation_function"]
        self.learning_rate       = dictionary["learning_rate"]
        self.dropout_size        = dictionary["dropout_size"]
        self.neuron_difference   = dictionary["neuron_difference"]
        self.batch_size          = dictionary["batch_size"]
        self.epoch_count         = dictionary["epochs"]
        self.beta_1_value        = dictionary["beta_1"]
        self.beta_2_value        = dictionary["beta_2"]
        self.verbose_yn          = dictionary["verbose_yn"]
        self.final_activation    = dictionary["final_activation"]
        self.input_shape         = dictionary["input_shape"]
        self.patience            = dictionary["patience"]

        self.early_stopping = keras.callbacks.EarlyStopping(
            patience  = self.patience, 
            min_delta = 0.001,
            restore_best_weights = True
        ) 

    def singleCreator(self, initial_bias: float = None, class_num: int = None):
        if self.final_activation.lower()   == "sigmoid":
            final_activation_function  = "sigmoid"
            final_layer_num            = 1
        elif self.final_activation.lower() == "softmax":
            final_activation_function  = "softmax"
            final_layer_num            = class_num
        elif self.final_activation.lower() == "linear":
            final_activation_function  = "linear"
            final_layer_num            = 1

        input_layer = keras.layers.Input(shape = (self.input_shape), name = f"Input_Layer")

        self.num_list = sorted(list(range(self.base_neurons, self.base_neurons + (self.neuron_difference * self.layer_num), self.neuron_difference)), reverse = True)
        self.num_list.append(0)

        layer_list = [input_layer]

        for (a, b) in enumerate(self.num_list):
            layer_list.append(keras.layers.Dense(b)                            (layer_list[-1]))
            layer_list.append(keras.layers.BatchNormalization()                (layer_list[-1]))
            layer_list.append(keras.layers.Activation(self.activation_function)(layer_list[-1]))
            layer_list.append(keras.layers.Dropout(self.dropout_size)          (layer_list[-1]))

        output_layer = keras.layers.Dense(final_layer_num, name = f"Output_Layer", activation = final_activation_function)(layer_list[-1]) 
        self.model   = keras.Model(inputs = input_layer, outputs = output_layer)

        loss_dict = {
            "sigmoid" : keras.losses.BinaryCrossentropy(),
            "softmax" : keras.losses.CategoricalCrossentropy(),
            "linear"  : "mean_squared_error"
        }

        metrics_dict = {
            "sigmoid" : tf.keras.metrics.BinaryAccuracy(),
            "softmax" : tf.keras.metrics.CategoricalAccuracy(),
            "linear"  : tf.keras.metrics.MeanAbsoluteError()
        }

        self.model.compile(
            optimizer = tf.keras.optimizers.Adam(
                learning_rate = self.learning_rate,
                beta_1        = self.beta_1_value, 
                beta_2        = self.beta_2_value
            ),
            loss    = loss_dict[final_activation_function],
            metrics = metrics_dict[final_activation_function]
        )

        del self.num_list[-1]
    
    def modelFitter(self, X_train: pd.core.frame.DataFrame, X_test: pd.core.frame.DataFrame, y_train: pd.core.frame.DataFrame, y_test: pd.core.frame.DataFrame):
        self.X_train = X_train
        self.X_test  = X_test
        self.y_train = y_train
        self.y_test  = y_test

        self.start_time = f"{dt.datetime.now()}"[0:16]

        if self.y_train.shape[1] == 1:
            callbacks_list = [self.early_stopping]
        elif self.y_train.shape[1] > 1:
            callbacks_list = [self.early_stopping for i in range(y_train.shape[1])]

        self.history = self.model.fit(
            {"Input_Layer"  : X_train},
            {"Output_Layer" : y_train},
            validation_data = (
                {"Input_Layer"  : X_test},
                {"Output_Layer" : y_test}
            ),
            epochs     = self.epoch_count, 
            batch_size = self.batch_size,
            callbacks  = callbacks_list,
            verbose    = self.verbose_yn
        )

        self.end_time = f"{dt.datetime.now()}"[0:16]

        self.history_df = pd.DataFrame(self.history.history)

    def modelResults(self, X_data: pd.core.frame.DataFrame, y_data: pd.core.frame.DataFrame, target:str):
        self.X_data = X_data
        self.y_data = y_data

        pred_df = pd.DataFrame(self.model.predict(X_data), columns = ["Predicted Probability"])
        pred_df["Actual Target"] = list(self.y_data[target])

        threshold_list = []
        accuracy_list  = []
        recall_list    = []
        precision_list = []
        f1_score_list  = []
        rp_diff_list   = []

        for i in [j / 10 for j in range(1, 10)]:
            pred_df.loc[pred_df["Predicted Probability"] >= i, "Predicted Target"] = 1
            pred_df.loc[pred_df["Predicted Probability"]  < i, "Predicted Target"] = 0

            threshold_list.append(i)
            accuracy_list.append(accuracy_score(pred_df["Predicted Target"], pred_df["Actual Target"]))
            recall_list.append(recall_score(pred_df["Predicted Target"], pred_df["Actual Target"]))
            precision_list.append(precision_score(pred_df["Predicted Target"], pred_df["Actual Target"]))
            f1_score_list.append(f1_score(pred_df["Predicted Target"], pred_df["Actual Target"]))

        performance_table = pd.DataFrame({
            "Threshold" : threshold_list, 
            "Accuracy"  : accuracy_list, 
            "Recall"    : recall_list, 
            "Precision" : precision_list, 
            "F1 Score"  : f1_score_list, 
            "RP Diff"   : [abs(a - b) for (a, b) in zip(recall_list, precision_list)]
        })

        self.performance_table = performance_table[performance_table["F1 Score"] != 0].sort_values(by = ["RP Diff"]).reset_index(drop = True)
        self.bestThreshold     = list(self.performance_table["Threshold"])[0]
        self.bestAccuracy      = list(self.performance_table["Accuracy"])[0]
        self.bestRecall        = list(self.performance_table["Recall"])[0]
        self.bestPrecision     = list(self.performance_table["Precision"])[0]
        self.bestF1Score       = list(self.performance_table["F1 Score"])[0]
